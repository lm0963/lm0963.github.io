---
layout: post
title: "CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞"
description: "CVE-2010-2883"
categories: [2018/05]
tags: [笔记,CVE]
redirect_from:
  - /2018/05/05/
---

> 学习《漏洞战争》中的例子

* 测试环境

	|---
	||测试版本
	|:-:|:-
	|操作系统|windows XP SP3
	|调试器|Immunity Debugger
	|漏洞软件|Adobe Reader 9.3

* 漏洞函数

> CoolType.dll中对SING表格进行处理的函数。定位方法：先IDA反汇编CoolType.dll库，然后Shift+F12打开字符串窗口，搜索SING，Ctrl+X查看引用，找到下方有调用strcat的代码处就是漏洞代码，下面是反编译后的漏洞代码

&emsp;&emsp;&emsp;![cve-2010-2883-code](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-code.png)

* 漏洞成因

```
typedef sturct_SING
{
	char tag[4];//"SING"
	ULONG checkSum;//校验和
	ULONG offset;//相对文件偏移
	ULONG length;//数据长度
} TableEntry;
```

> 根据TableEntry的offset，找到SING表的数据，然后再偏移0x10找到uniqueName域，在将uniqueName复制到栈上时，没有判断长度，导致栈溢出，覆盖栈上高地址数据

* 调试过程

> 先打开调试器和Adobe Reader，然后调试器附加到Adobe Reader上，接着在上面找到的strcat处下断点，运行，打开恶意pdf文件，会发现调试器产生异常停下，不管，直接Shift+F9忽略异常，直到strcat处停下

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-strcat.png)

> 不断单步执行，最后发现在0x808b308处调用call [eax]开始执行shellcode

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-rop_begin.png)

从strcat 到 call [eax]经历的过程  

> 1.strcat之后会在0x803deaf处跳转到0x8016bde处  

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-803deaf.png)

> 2.跳转到0x8016bde后继续执行到0x8016c56会跳转到0x801bb21处  

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-8016c56.png)

> 3.跳转到0x801bb21后继续执行到0x801bb41会通过call [eax]跳转到808b116处  

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-801bb41.png)

> 4.跳转到0x808b116后继续执行到0x808b308就会call [eax]执行shellcode  

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-808b308.png)

> 最后一个eax的值是edi+0x3c（0x12e6d0）地址处的值  
> 溢出主要是覆盖了栈上高地址的数据，并没有等到函数返回才跳转到shellcode，而是在strcat下面的函数中就会引用栈上保存的地址，所以覆盖该地址就可以控制eip（类似于覆盖C++中的虚函数指针）

&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-before_overwrite.png)  
&emsp;&emsp;&emsp;![cve-2010-2883-strcat](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2010-2883-after_overwrite.png)