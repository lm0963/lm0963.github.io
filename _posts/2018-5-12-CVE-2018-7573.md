---
layout: post
title: "CVE-2018-7573 FTPShell Client 6.7 - Buffer Overflow"
description: "CVE-2018-7573"
categories: [2018/05]
tags: [笔记,CVE]
redirect_from:
  - /2018/05/12/
---

> 在exploit-db上看到FTPShell Client 6.7存在缓冲区溢出漏洞，所以决定复现并学习一波

* 测试环境

	|---
	||测试版本
	|:-:|:-
	|操作系统|windows 7
	|调试器|Immunity Debugger
	|漏洞软件|FTPShell Client 6.7

* 漏洞成因

> 在栈上开辟了一块0x194字节大小的缓冲区，但是复制数据到缓冲区是通过判断是否为0来决定是否结束，那么一段超过0x194字节大小的数据（不包含\00）就会造成缓冲区溢出

* 调试过程

> 下载exploit-db上的py脚本,把payload改成400个'a'，python运行，调试器打开FTPShell,F9运行，然后FTPShell连上本地的21端口，发现会在0x467863处产生写地址异常断下，打开堆栈窗口，发现是0x46535D地址处通过call edx调用了崩溃的函数，在这里下断点

&emsp;&emsp;&emsp;![cve-2018-7573-crash](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/crash.png)

&emsp;&emsp;&emsp;![cve-2018-7573-stack](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/stack.png)

> 单步调试程序，发现会不断调用call eax，并且每一次call eax处理一次连接过程中的对话，在第五次调用call eax时就是处理目录的代码。单步执行，发现在0x44DDDD处会调用sub_44F0C8函数将目录字符串复制到栈上，在栈上分配的缓冲区大小为0x194,复制前后栈情况如下对比(返回地址位于0x18F974)：

&emsp;&emsp;&emsp;![cve-2018-7573-44dddd](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/44dddd.png)

&emsp;&emsp;&emsp;![cve-2018-7573-smash_before](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/smash_before.png)

&emsp;&emsp;&emsp;![cve-2018-7573-smash_after](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/smash_after.png)

> 单步调试到0x44DE4C，这里会call [ebp-4]（ebp=0x18F970）,这个地址是我们可控的，所以覆盖到栈上的地址0x18F96C处，就可以劫持eip，控制程序执行流程。由于\00是坏字符，所以只能覆盖0x18F96C地址的低三位。

&emsp;&emsp;&emsp;![cve-2018-7573-call_crash](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/call_crash.png)

* 漏洞利用

> 使用mona搜索jmp esp，可以看到有很多jmp esp位于没有打开ASLR的ftpshell.exe中，但是esp并没有指向shellcode的位置，而是指向了shellcode的前面一点，最后查看exploit-db上对应的利用脚本，发现esi最终指向的是一片复制了shellcode的内存，所以可以用jmp esi来执行shellcode，shellcode可以使用msfvenom生成
> msfvenom -p windows/exec CMD=cmd.exe -b '\x00\x22\x0a\x0d' -f python

&emsp;&emsp;&emsp;![cve-2018-7573-jmp_esp](https://raw.githubusercontent.com/lm0963/lm0963.github.io/master/assets/images/screenshots/cve-2018-7573/jmp_esi.png)
